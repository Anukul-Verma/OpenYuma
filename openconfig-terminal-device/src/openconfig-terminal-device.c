
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.5-5

    Combined SIL module
    module openconfig-terminal-device
    revision 2017-07-08
    namespace http://openconfig.net/yang/terminal-device
    organization OpenConfig working group

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "openconfig-terminal-device.h"

/* module static variables */
static ncx_module_t *openconfig_terminal_device_mod;
static obj_template_t *terminal_device_obj;
static val_value_t *terminal_device_val;
extern struct smiclient_globals *azg;

/* put your static variables here */

/********************************************************************
* FUNCTION y_openconfig_terminal_device_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_openconfig_terminal_device_init_static_vars (void)
{
    openconfig_terminal_device_mod = NULL;
    terminal_device_obj = NULL;
    terminal_device_val = NULL;

    /* init your static variables here */

} /* y_openconfig_terminal_device_init_static_vars */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_config_edit
* 
* Edit database object callback
* Path: /terminal-device/config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_config_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    return res;

} /* openconfig_terminal_device_terminal_device_state_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_index_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/index
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_index_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_index_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_index_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_index_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/index
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_index_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_index_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_index_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_description_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_description_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_admin_state_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/admin-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_admin_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_admin_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_admin_state_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_rate_class_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/rate-class
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_rate_class_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_rate_class_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_rate_class_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_trib_protocol_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/trib-protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_trib_protocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_trib_protocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_trib_protocol_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_logical_channel_type_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/logical-channel-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_logical_channel_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_logical_channel_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_logical_channel_type_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_loopback_mode_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/loopback-mode
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_loopback_mode_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_loopback_mode_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_loopback_mode_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_test_signal_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config/test-signal
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_test_signal_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_test_signal_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_test_signal_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_config_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_config_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_index_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/index
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_index_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint32 index;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_index_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the index var here, change zero */
    index = 0;
    //VAL_UINT(dstval) = index;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_index_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_description_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/description
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_description_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *description;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_description_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the description var here, change EMPTY_STRING */
    description = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        description);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_description_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_admin_state_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/admin-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_admin_state_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *admin_state;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_admin_state_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the admin_state var here, change enum */
    admin_state = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        admin_state);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_admin_state_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_rate_class_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/rate-class
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_rate_class_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const val_idref_t *rate_class;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_rate_class_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the rate_class var here, change EMPTY_STRING */
    rate_class = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        rate_class);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_rate_class_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_trib_protocol_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/trib-protocol
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_trib_protocol_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const val_idref_t *trib_protocol;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_trib_protocol_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the trib_protocol var here, change EMPTY_STRING */
    trib_protocol = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        trib_protocol);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_trib_protocol_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_logical_channel_type_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/logical-channel-type
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_logical_channel_type_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const val_idref_t *logical_channel_type;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_logical_channel_type_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the logical_channel_type var here, change EMPTY_STRING */
    logical_channel_type = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        logical_channel_type);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_logical_channel_type_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_loopback_mode_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/loopback-mode
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_loopback_mode_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *loopback_mode;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_loopback_mode_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the loopback_mode var here, replace (void) or use default value */
    (void)loopback_mode;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        (const xmlChar *)"NONE");

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_loopback_mode_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_test_signal_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/test-signal
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_test_signal_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean test_signal;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_test_signal_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the test_signal var here, change TRUE if needed */
    //test_signal = TRUE;VAL_BOOL(dstval) = test_signal;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_test_signal_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_link_state_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/state/link-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_state_link_state_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *link_state;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_state_link_state_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the link_state var here, change enum */
    link_state = (const xmlChar *)"UP";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        link_state);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_link_state_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/state/index */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_index,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_index_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/description */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_description,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_description_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/admin-state */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_admin_state,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_admin_state_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/rate-class */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_rate_class,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_rate_class_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/trib-protocol */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_trib_protocol,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_trib_protocol_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/logical-channel-type */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_logical_channel_type,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_logical_channel_type_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/loopback-mode */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_loopback_mode,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_loopback_mode_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/test-signal */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_test_signal,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_test_signal_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/state/link-state */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_link_state,
        openconfig_terminal_device_terminal_device_logical_channels_channel_state_link_state_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_state_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_transmit_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/otn/config/tti-msg-transmit
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_transmit_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_transmit_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_transmit_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_expected_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/otn/config/tti-msg-expected
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_expected_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_expected_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_expected_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_auto_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/otn/config/tti-msg-auto
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_auto_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_auto_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_auto_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/otn/config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_transmit_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/tti-msg-transmit
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_transmit_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *tti_msg_transmit;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_transmit_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the tti_msg_transmit var here, change EMPTY_STRING */
    tti_msg_transmit = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        tti_msg_transmit);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_transmit_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_expected_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/tti-msg-expected
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_expected_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *tti_msg_expected;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_expected_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the tti_msg_expected var here, change EMPTY_STRING */
    tti_msg_expected = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        tti_msg_expected);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_expected_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_auto_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/tti-msg-auto
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_auto_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean tti_msg_auto;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_auto_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the tti_msg_auto var here, change TRUE if needed */
    //tti_msg_auto = TRUE;VAL_BOOL(dstval) = tti_msg_auto;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_auto_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_recv_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/tti-msg-recv
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_recv_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *tti_msg_recv;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_recv_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the tti_msg_recv var here, change EMPTY_STRING */
    tti_msg_recv = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        tti_msg_recv);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_recv_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_rdi_msg_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/rdi-msg
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_rdi_msg_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *rdi_msg;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_rdi_msg_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the rdi_msg var here, change EMPTY_STRING */
    rdi_msg = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        rdi_msg);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_rdi_msg_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_errored_seconds_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/errored-seconds
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_errored_seconds_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 errored_seconds;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_errored_seconds_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the errored_seconds var here, change zero */
    errored_seconds = 0;
    //VAL_ULONG(dstval) = errored_seconds;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_errored_seconds_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_severely_errored_seconds_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/severely-errored-seconds
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_severely_errored_seconds_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 severely_errored_seconds;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_severely_errored_seconds_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the severely_errored_seconds var here, change zero */
    severely_errored_seconds = 0;
    //VAL_ULONG(dstval) = severely_errored_seconds;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_severely_errored_seconds_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_unavailable_seconds_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/unavailable-seconds
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_unavailable_seconds_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 unavailable_seconds;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_unavailable_seconds_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the unavailable_seconds var here, change zero */
    unavailable_seconds = 0;
    //VAL_ULONG(dstval) = unavailable_seconds;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_unavailable_seconds_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_code_violations_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/code-violations
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_code_violations_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 code_violations;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_code_violations_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the code_violations var here, change zero */
    code_violations = 0;
    //VAL_ULONG(dstval) = code_violations;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_code_violations_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_uncorrectable_words_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/fec-uncorrectable-words
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_uncorrectable_words_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 fec_uncorrectable_words;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_uncorrectable_words_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the fec_uncorrectable_words var here, change zero */
    fec_uncorrectable_words = 0;
    //VAL_ULONG(dstval) = fec_uncorrectable_words;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_uncorrectable_words_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bytes_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/fec-corrected-bytes
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bytes_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 fec_corrected_bytes;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bytes_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the fec_corrected_bytes var here, change zero */
    fec_corrected_bytes = 0;
    //VAL_ULONG(dstval) = fec_corrected_bytes;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bytes_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bits_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/fec-corrected-bits
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bits_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 fec_corrected_bits;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bits_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the fec_corrected_bits var here, change zero */
    fec_corrected_bits = 0;
    //VAL_ULONG(dstval) = fec_corrected_bits;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bits_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_background_block_errors_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/background-block-errors
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_background_block_errors_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 background_block_errors;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_background_block_errors_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the background_block_errors var here, change zero */
    background_block_errors = 0;
    //VAL_ULONG(dstval) = background_block_errors;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_background_block_errors_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_instant_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/instant
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_instant_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 instant;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_instant_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the instant var here, change zero */
    instant = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        instant);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_instant_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_avg_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/avg
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_avg_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 avg;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_avg_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the avg var here, change zero */
    avg = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        avg);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_avg_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/min
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 min;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min var here, change zero */
    min = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        min);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/max
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 max;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max var here, change zero */
    max = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        max);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_interval_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/interval
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_interval_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 interval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_interval_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the interval var here, change zero */
    interval = 0;
    //VAL_ULONG(dstval) = interval;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_interval_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/min-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 min_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min_time var here, change zero */
    min_time = 0;
    //VAL_ULONG(dstval) = min_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/max-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 max_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max_time var here, change zero */
    max_time = 0;
    //VAL_ULONG(dstval) = max_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/otn/state/pre-fec-ber
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/instant */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_instant,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_instant_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/avg */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_avg,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_avg_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/min */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/max */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/interval */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_interval,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_interval_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/min-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_min_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/pre-fec-ber/max-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_max_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_instant_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/instant
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_instant_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 instant;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_instant_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the instant var here, change zero */
    instant = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        instant);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_instant_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_avg_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/avg
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_avg_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 avg;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_avg_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the avg var here, change zero */
    avg = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        avg);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_avg_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/min
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 min;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min var here, change zero */
    min = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        min);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/max
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 max;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max var here, change zero */
    max = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        max);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_interval_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/interval
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_interval_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 interval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_interval_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the interval var here, change zero */
    interval = 0;
    //VAL_ULONG(dstval) = interval;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_interval_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/min-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 min_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min_time var here, change zero */
    min_time = 0;
    //VAL_ULONG(dstval) = min_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber/max-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 max_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max_time var here, change zero */
    max_time = 0;
    //VAL_ULONG(dstval) = max_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/otn/state/post-fec-ber
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/instant */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_instant,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_instant_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/avg */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_avg,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_avg_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/min */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/max */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/interval */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_interval,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_interval_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/min-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_min_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/post-fec-ber/max-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_max_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_instant_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/instant
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_instant_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 instant;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_instant_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the instant var here, change zero */
    instant = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        instant);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_instant_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_avg_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/avg
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_avg_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 avg;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_avg_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the avg var here, change zero */
    avg = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        avg);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_avg_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/min
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 min;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min var here, change zero */
    min = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        min);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/max
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 max;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max var here, change zero */
    max = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        max);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_interval_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/interval
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_interval_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 interval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_interval_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the interval var here, change zero */
    interval = 0;
    //VAL_ULONG(dstval) = interval;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_interval_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/min-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 min_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min_time var here, change zero */
    min_time = 0;
    //VAL_ULONG(dstval) = min_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/q-value/max-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 max_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max_time var here, change zero */
    max_time = 0;
    //VAL_ULONG(dstval) = max_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/otn/state/q-value
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/instant */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_instant,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_instant_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/avg */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_avg,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_avg_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/min */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/max */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/interval */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_interval,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_interval_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/min-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_min_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/q-value/max-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_max_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_instant_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/instant
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_instant_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 instant;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_instant_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the instant var here, change zero */
    instant = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        instant);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_instant_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_avg_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/avg
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_avg_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 avg;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_avg_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the avg var here, change zero */
    avg = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        avg);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_avg_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/min
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 min;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min var here, change zero */
    min = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        min);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/max
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 max;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max var here, change zero */
    max = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        max);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_interval_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/interval
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_interval_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 interval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_interval_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the interval var here, change zero */
    interval = 0;
    //VAL_ULONG(dstval) = interval;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_interval_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/min-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 min_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the min_time var here, change zero */
    min_time = 0;
    //VAL_ULONG(dstval) = min_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_time_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/otn/state/esnr/max-time
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_time_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 max_time;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_time_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max_time var here, change zero */
    max_time = 0;
    //VAL_ULONG(dstval) = max_time;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_time_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/otn/state/esnr
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/instant */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_instant,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_instant_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/avg */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_avg,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_avg_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/min */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/max */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/interval */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_interval,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_interval_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/min-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_min_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_min_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/esnr/max-time */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_max_time,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_max_time_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/otn/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/otn/state/tti-msg-transmit */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_tti_msg_transmit,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_transmit_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/tti-msg-expected */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_tti_msg_expected,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_expected_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/tti-msg-auto */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_tti_msg_auto,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_auto_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/tti-msg-recv */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_tti_msg_recv,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_tti_msg_recv_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/rdi-msg */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_rdi_msg,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_rdi_msg_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/errored-seconds */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_errored_seconds,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_errored_seconds_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/severely-errored-seconds */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_severely_errored_seconds,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_severely_errored_seconds_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/unavailable-seconds */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_unavailable_seconds,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_unavailable_seconds_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/code-violations */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_code_violations,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_code_violations_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/fec-uncorrectable-words */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_fec_uncorrectable_words,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_uncorrectable_words_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/fec-corrected-bytes */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_fec_corrected_bytes,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bytes_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/fec-corrected-bits */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_fec_corrected_bits,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_fec_corrected_bits_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/otn/state/background-block-errors */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_background_block_errors,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_background_block_errors_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_pre_fec_ber,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_pre_fec_ber_mro(childval);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_post_fec_ber,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_post_fec_ber_mro(childval);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_q_value,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_q_value_mro(childval);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_esnr,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_esnr_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/otn
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_otn_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_otn_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_otn_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/otn
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_otn_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_otn_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_logical_channels_channel_otn_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_otn_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_config_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_config_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_control_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-mac-control-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_control_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_mac_control_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_control_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_mac_control_frames var here, change zero */
    in_mac_control_frames = 0;
    //VAL_ULONG(dstval) = in_mac_control_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_control_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_pause_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-mac-pause-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_pause_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_mac_pause_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_pause_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_mac_pause_frames var here, change zero */
    in_mac_pause_frames = 0;
    //VAL_ULONG(dstval) = in_mac_pause_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_pause_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_oversize_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-oversize-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_oversize_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_oversize_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_oversize_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_oversize_frames var here, change zero */
    in_oversize_frames = 0;
    //VAL_ULONG(dstval) = in_oversize_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_oversize_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_jabber_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-jabber-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_jabber_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_jabber_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_jabber_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_jabber_frames var here, change zero */
    in_jabber_frames = 0;
    //VAL_ULONG(dstval) = in_jabber_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_jabber_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_fragment_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-fragment-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_fragment_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_fragment_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_fragment_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_fragment_frames var here, change zero */
    in_fragment_frames = 0;
    //VAL_ULONG(dstval) = in_fragment_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_fragment_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_8021q_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-8021q-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_8021q_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_8021q_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_8021q_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_8021q_frames var here, change zero */
    in_8021q_frames = 0;
    //VAL_ULONG(dstval) = in_8021q_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_8021q_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_crc_errors_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/in-crc-errors
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_crc_errors_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 in_crc_errors;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_crc_errors_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the in_crc_errors var here, change zero */
    in_crc_errors = 0;
    //VAL_ULONG(dstval) = in_crc_errors;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_crc_errors_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_control_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/out-mac-control-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_control_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 out_mac_control_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_control_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the out_mac_control_frames var here, change zero */
    out_mac_control_frames = 0;
    //VAL_ULONG(dstval) = out_mac_control_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_control_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_pause_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/out-mac-pause-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_pause_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 out_mac_pause_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_pause_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the out_mac_pause_frames var here, change zero */
    out_mac_pause_frames = 0;
    //VAL_ULONG(dstval) = out_mac_pause_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_pause_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_8021q_frames_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ethernet/state/out-8021q-frames
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_8021q_frames_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 out_8021q_frames;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_8021q_frames_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the out_8021q_frames var here, change zero */
    out_8021q_frames = 0;
    //VAL_ULONG(dstval) = out_8021q_frames;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_8021q_frames_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/ethernet/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-mac-control-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_mac_control_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_control_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-mac-pause-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_mac_pause_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_mac_pause_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-oversize-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_oversize_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_oversize_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-jabber-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_jabber_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_jabber_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-fragment-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_fragment_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_fragment_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-8021q-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_8021q_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_8021q_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/in-crc-errors */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_in_crc_errors,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_in_crc_errors_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/out-mac-control-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_out_mac_control_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_control_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/out-mac-pause-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_out_mac_pause_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_mac_pause_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/ethernet/state/out-8021q-frames */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_out_8021q_frames,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_out_8021q_frames_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/ethernet
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/ethernet
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_transceiver_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/ingress/config/transceiver
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_transceiver_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_transceiver_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_transceiver_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_physical_channel_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/ingress/config/physical-channel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_physical_channel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_physical_channel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_physical_channel_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/ingress/config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_transceiver_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ingress/state/transceiver
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_transceiver_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *transceiver;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_transceiver_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the transceiver var here, change EMPTY_STRING */
    transceiver = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        transceiver);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_transceiver_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_physical_channel_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/ingress/state/physical-channel
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_physical_channel_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *physical_channel;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_physical_channel_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the physical_channel var here, change EMPTY_STRING */
    physical_channel = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        physical_channel);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_physical_channel_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/ingress/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/ingress/state/transceiver */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_transceiver,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_transceiver_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }
    /* container state not handled!!! */

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/ingress
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/ingress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_index_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/index
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_index_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_index_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_index_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_index_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/index
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_index_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_index_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_index_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_description_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/description
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_description_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_description_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_description_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_assignment_type_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/assignment-type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_assignment_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_assignment_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_assignment_type_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_logical_channel_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/logical-channel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_logical_channel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_logical_channel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_COMMIT:
        /* database manipulation done here */
        break;
    case AGT_CB_APPLY:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_logical_channel_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_optical_channel_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/optical-channel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_optical_channel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_optical_channel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_optical_channel_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_allocation_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/allocation
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_allocation_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_allocation_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_allocation_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    val_value_t* idx1_val = 0;
    val_value_t* idx2_val = 0;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_COMMIT:
        /* database manipulation done here */
        break;
    case AGT_CB_APPLY:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
        case OP_EDITOP_REPLACE:
        case OP_EDITOP_CREATE:
            idx1_val = val_find_child (newval, y_openconfig_terminal_device_M_openconfig_terminal_device, 
                                      y_openconfig_terminal_device_N_index);
            idx2_val = val_find_child (newval, y_openconfig_terminal_device_M_openconfig_terminal_device, 
                                      y_openconfig_terminal_device_N_logical_channel);
            if (idx1_val && idx2_val)
              res = smi_nsm_transceiver_cross_connect_create_api_auto (azg, VAL_UINT16(idx1_val), VAL_UINT16(idx2_val));
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_index_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/index
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_index_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint32 index;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_index_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the index var here, change zero */
    index = 0;
    //VAL_UINT(dstval) = index;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_index_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_description_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/description
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_description_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *description;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_description_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the description var here, change EMPTY_STRING */
    description = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        description);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_description_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_assignment_type_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/assignment-type
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_assignment_type_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *assignment_type;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_assignment_type_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the assignment_type var here, change enum */
    assignment_type = (const xmlChar *)"LOGICAL_CHANNEL";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        assignment_type);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_assignment_type_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_logical_channel_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/logical-channel
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_logical_channel_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint32 logical_channel;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_logical_channel_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the logical_channel var here, change zero */
    logical_channel = 0;
    //VAL_UINT(dstval) = logical_channel;

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_logical_channel_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_optical_channel_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/optical-channel
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_optical_channel_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *optical_channel;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_optical_channel_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the optical_channel var here, change EMPTY_STRING */
    optical_channel = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        optical_channel);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_optical_channel_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_allocation_get
* 
* Get database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/allocation
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_allocation_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    int64 allocation;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_allocation_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the allocation var here, change zero */
    allocation = (const xmlChar *)"0.0";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        allocation);

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_allocation_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/index */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_index,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_index_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/description */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_description,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_description_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/assignment-type */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_assignment_type,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_assignment_type_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/logical-channel */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_logical_channel,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_logical_channel_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/optical-channel */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_optical_channel,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_optical_channel_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/logical-channels/channel/logical-channel-assignments/assignment/state/allocation */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_allocation,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_allocation_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments/assignment
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    val_value_t* idx_val = 0;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_COMMIT:
        /* database manipulation done here */
        break;
    case AGT_CB_APPLY:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            idx_val = val_find_child (curval, y_openconfig_terminal_device_M_openconfig_terminal_device, 
                                      y_openconfig_terminal_device_N_index);
            if (idx_val)
              res = smi_nsm_transceiver_cross_connect_delete_api_auto (azg, atoi(idx_val->v.str));
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel/logical-channel-assignments
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_mro
* 
* Make read-only child nodes
* Path: /terminal-device/logical-channels/channel
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_logical_channels_channel_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_logical_channels_channel_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_channel_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels/channel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_channel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_channel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_logical_channels_channel_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_channel_edit */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_logical_channels_edit
* 
* Edit database object callback
* Path: /terminal-device/logical-channels
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_logical_channels_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_logical_channels_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_logical_channels_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mode_mode_id_get
* 
* Get database object callback
* Path: /terminal-device/operational-modes/mode/mode-id
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_operational_modes_mode_mode_id_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *mode_id;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_operational_modes_mode_mode_id_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the mode_id var here, change EMPTY_STRING */
    mode_id = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        mode_id);

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mode_mode_id_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mode_config_mro
* 
* Make read-only child nodes
* Path: /terminal-device/operational-modes/mode/config
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_operational_modes_mode_config_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mode_config_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mode_state_mode_id_get
* 
* Get database object callback
* Path: /terminal-device/operational-modes/mode/state/mode-id
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_operational_modes_mode_state_mode_id_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint16 mode_id;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_operational_modes_mode_state_mode_id_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the mode_id var here, change zero */
    mode_id = 0;
    //VAL_UINT16(dstval) = mode_id;

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mode_state_mode_id_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mode_state_description_get
* 
* Get database object callback
* Path: /terminal-device/operational-modes/mode/state/description
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_operational_modes_mode_state_description_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *description;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_operational_modes_mode_state_description_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the description var here, change EMPTY_STRING */
    description = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        description);

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mode_state_description_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mode_state_vendor_id_get
* 
* Get database object callback
* Path: /terminal-device/operational-modes/mode/state/vendor-id
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_operational_modes_mode_state_vendor_id_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *vendor_id;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_operational_modes_mode_state_vendor_id_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the vendor_id var here, change EMPTY_STRING */
    vendor_id = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        vendor_id);

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mode_state_vendor_id_get */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mode_state_mro
* 
* Make read-only child nodes
* Path: /terminal-device/operational-modes/mode/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_operational_modes_mode_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /terminal-device/operational-modes/mode/state/mode-id */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_mode_id,
        openconfig_terminal_device_terminal_device_operational_modes_mode_state_mode_id_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/operational-modes/mode/state/description */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_description,
        openconfig_terminal_device_terminal_device_operational_modes_mode_state_description_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /terminal-device/operational-modes/mode/state/vendor-id */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_openconfig_terminal_device_N_vendor_id,
        openconfig_terminal_device_terminal_device_operational_modes_mode_state_vendor_id_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mode_state_mro */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_mro
* 
* Make read-only child nodes
* Path: /terminal-device/operational-modes
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_operational_modes_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    /* container operational-modes not handled!!! */

    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_operational_modes_edit
* 
* Edit database object callback
* Path: /terminal-device/operational-modes
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_operational_modes_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_operational_modes_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_operational_modes_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_operational_modes_edit */

/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_mro
* 
* Make read-only child nodes
* Path: /terminal-device
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    openconfig_terminal_device_terminal_device_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = openconfig_terminal_device_terminal_device_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* openconfig_terminal_device_terminal_device_mro */


/********************************************************************
* FUNCTION openconfig_terminal_device_terminal_device_edit
* 
* Edit database object callback
* Path: /terminal-device
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t openconfig_terminal_device_terminal_device_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter openconfig_terminal_device_terminal_device_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = openconfig_terminal_device_terminal_device_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* openconfig_terminal_device_terminal_device_edit */

/********************************************************************
* FUNCTION y_openconfig_terminal_device_init
* 
* initialize the openconfig-terminal-device server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_openconfig_terminal_device_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    agt_profile_t *agt_profile = agt_get_profile();

    y_openconfig_terminal_device_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_openconfig_terminal_device_M_openconfig_terminal_device)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_openconfig_terminal_device_R_openconfig_terminal_device)) {
        return ERR_NCX_WRONG_VERSION;
    }
    res = ncxmod_load_module(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        &agt_profile->agt_savedevQ,
        &openconfig_terminal_device_mod);
    if (res != NO_ERR) {
        return res;
    }

    terminal_device_obj = ncx_find_object(
        openconfig_terminal_device_mod,
        y_openconfig_terminal_device_N_terminal_device);
    if (openconfig_terminal_device_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/config",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_config_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/index",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_index_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/index",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_index_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/description",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_description_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/admin-state",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_admin_state_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/rate-class",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_rate_class_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/trib-protocol",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_trib_protocol_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/logical-channel-type",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_logical_channel_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/loopback-mode",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_loopback_mode_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/test-signal",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_config_test_signal_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config/tti-msg-transmit",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_transmit_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config/tti-msg-expected",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_expected_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config/tti-msg-auto",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_otn_config_tti_msg_auto_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ethernet",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ethernet/config",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ethernet_config_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress/config",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress/config/transceiver",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_transceiver_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress/config/physical-channel",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_ingress_config_physical_channel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/index",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_index_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/index",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_index_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/description",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_description_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/assignment-type",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_assignment_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/logical-channel",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_logical_channel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/optical-channel",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_optical_channel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/allocation",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_logical_channels_channel_logical_channel_assignments_assignment_config_allocation_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/operational-modes",
        y_openconfig_terminal_device_R_openconfig_terminal_device,
        openconfig_terminal_device_terminal_device_operational_modes_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */
    
    return res;
} /* y_openconfig_terminal_device_init */

/********************************************************************
* FUNCTION y_openconfig_terminal_device_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_openconfig_terminal_device_init2 (void)
{
    status_t res = NO_ERR;

    /* put your init2 code here */

    return res;
} /* y_openconfig_terminal_device_init2 */

/********************************************************************
* FUNCTION y_openconfig_terminal_device_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_openconfig_terminal_device_cleanup (void)
{
    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/config");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/index");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/index");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/description");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/admin-state");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/rate-class");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/trib-protocol");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/logical-channel-type");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/loopback-mode");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/config/test-signal");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config/tti-msg-transmit");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config/tti-msg-expected");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/otn/config/tti-msg-auto");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ethernet");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ethernet/config");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress/config");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress/config/transceiver");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/ingress/config/physical-channel");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/index");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/index");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/description");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/assignment-type");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/logical-channel");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/optical-channel");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/logical-channels/channel/logical-channel-assignments/assignment/config/allocation");

    agt_cb_unregister_callbacks(
        y_openconfig_terminal_device_M_openconfig_terminal_device,
        (const xmlChar *)"/terminal-device/operational-modes");

    /* put your cleanup code here */
    
} /* y_openconfig_terminal_device_cleanup */

/* END openconfig_terminal_device.c */
